--------------------------------------------------------------------------------
= Clojure Fundamentals =
--------------------------------------------------------------------------------
Core data structures         | Core Data Structures
  NOTE: Commas are not       |
  evaluated in expressions   |   nil
  (evaluated as whitespace)  |   true false                       :boolean
  so they are not needed but |   \a \b \b, etc...                 :Characters
  can be used as visual      |   "foo"                            :string
  separators (maps)          |   ; end of line comment
                             |   ;; full line comment
                             |   ;;; block comment
                             |   foo, 'foo                        :symbol
                             |   :foo                             :keyword
                             |
                             | Collections
                             |
                             |   (1 2 3 4 5)                      ; List
                             |   ["a" "b" "c" "d" "e"]            ; Vector
                             |   {:name "Grogu", :age 50}         ; Map
                             |   #(5 2 3 1 4)                     ; Set
Function call                |
                             |   (function arg-1 arg-2 ...)
                             |   (max 1 2 3)                      ; => 6
                             |   (filter odd? [1 2 3])            ; => (1 3)
                             |
               (conditional) |   (if (< 1 2) "a" "b")             ; => "a"
                             |
Immutability                 | All data structures in Clojure are immutable
                             |
Define variables             | (def first-name "Dave")
                             | (def ages [42 3 18])
                             |
  string concatinaion        | (str "I'm sorry " first-name)    ; => "I'm sorry Dave"
  conjoin (append) value     | (conj ages 21)                   ; => [42 3 18 21] (ages doesn't change)
                             |
                             |
Syntactic sugar for function | (defn greetings [name]             ; uses defn (define function)
Declarations                 |   (str "Hello" name))
                             |
Functions calls are the same | (greetings "Dave")                 ; => "Hello Dave"
                             |
Nested functions             | (filter odd? (map inc (range 5)))  ; => (1 3 5)
                             |
"Thread Last" for structuing | (->> (range 5)                     ; => (0 1 2 3 4)
Nested function to be more   |      (map inc)                     ; => (1 2 3 4 5)
natural (to read)            |      (filter odd?))                ; => (1 3 5)
                             |
                             | (->> Acts as sort of a pipe (Unix pipe)
--------------------------------------------------------------------------------
Collections
  List                       | '(1 2 "tom") <- start with a quote, separating commas are optional
                             |   - Elements are accessed sequentially
                             |
  Vector                     | [:test01 2 3 4 5 :test2]
                             |   - Elements are accessed by index
                             |     (def family ["bob" "jim" "Sally"])
                             |     (family 1)           ;; output: "jim"
                             |
  Maps                       | {:jam1 "strawberry" :jam2 "blackberry"}
                             | ;; - {:jam2 "blackberry" :jam1 "strawberry"}
                             |
Lists and Vectors            |
                             |
  Access first element       | (first '(:rabbit :pocket-watch :marmalade :dorr))
                             | ;; -> :rabit
                             |
  Access all but first       | (rest '(:rabbit :pocket-watch :marmalade :dorr))
  element                    | ;; -> :pocket-watch :marmalade :door
                             |
  Access the last element    | (last '(:rabbit :pocket-watch :marmalade :door))
                             | ;; -> :door
                             |
  Access the nth element     | (nth [:rabbit :pocket-watch :marmalade :door] 2)
  (faster with vectors)      | ;; -> :marmalade ()
                             |
  Add element an to the start| (cons 2 '(3 4))
  of a collection            | ;; -> (2 3 4)
                             |
  Add elemnt to the end      | (conj [:first :second] :third])
  of a vector                |
                             |
  count the number of elemen-| (conj [:toast :butter] :jam)
  ts in a colletion          | ;; -> [:toast :butter :jam]
                             |
  (conj adds elements to the | (conj [:toast :butter] :jam :honey)
  end of vectors, it adds to | ;; -> [:toast :butter :jam :honey]
  the begining of list       |
                             |
Maps                         |
  Retrieve (get) the value   | (get {:jam1 "Strawberry" :jam2 "blackberry"} :jam2)
  from a item in a map       | ;; -> "blackberry"
                             |
  set a default value if     | (get {:jam1 "strawberry" :jam2 "blackberry"} :jam3 "not found")
  a key in map is not present| ;; -> "not found"
                             |
  get using the key as a     | {:jam2 {:jam1 "strawberry" :jam2 "blackberry" :jam3 "marmalade"}}
  function                   | ;; -> "blackberry"
                             |
  Return only the keys of    | (keys {:jam1 "strawberry" :jam2 "blackberry" :jam3 "marmalade"})
  a mape                     | ;; -> {"marmalade" "blackberry" "stawberry"}
                             |
--------------------------------------------------------------------------------
  Define variable            | (def x 42) -> use the def keyword, variable name
                             |              then value
                             |
  Define new function        | (def greetings (fn [name] (str "Hello " name)))   <- is this how lamda functions are made?
  (using def)                |    -> use the "def" keyworkd then function name
                             |       parameters listed between brackets "[]"
                             |       then the body of the function within "()"
                             |       if you use the "def" keyword then you must
                             |       use "fn" keyworkd as the first items in the
                             |       body of the function
                             |
  (using defn)               | (defn foo [x] (* x 2))
                             |
--------------------------------------------------------------------------------
  Define local variables     | (let [a 5]               ;; a = 5
                             |    (println "a = " a)
                             |    (inc a))
                             |
  Multiple variables         | (let [a 5
                             |       b 7]
                             |    (println "a =" a)
                             |    (println "b =" b)
                             |    (+ a b))
                             |
                             |
--------------------------------------------------------------------------------
Built in Math operations     |
                             |
  Modulo                     | (mod 23 2)
                             | ;; -> 1
                             |
  Max (returns the max num   | (max 1 2 3 99 5 7)
    from list)               | ;; -> 99
                             |
  Min                        | (min 3 4 5 99 3)
                             | ;; -> 3
                             |
  Random (rational number)   | (rand 100)
                             | ;; -> 37.51551833853015 (for example)
                             |
  Random Integer             | (rand-int 100)
                             |
  PI                         | (Math/PI)
  (The Math module contains  |
   many mathimatical operat- |
   ions                      |
                             |
--------------------------------------------------------------------------------
Characters and Strings       |
                             |
  Single Character           | \H, \w
                             |
  String                     | "Hello", "World!"
                             |
  Regular Expressions        | #"[0-9]+"
                             |
  Get the length of string   | (.length "Hello!")
                             | ;; -> 6
                             |
  Convert to lower case      | (.toLowerCase "Hello!")
                             | ;; -> "hello!"
                             |
  Convert to upper case      | (.toUpperCase "Hello!")
                             | ;; -> "HELLO!"
                             |
  Return a character from a  | (.charAt "Hello!" 3)
  specific position          | ;; -> \l
                             |
--------------------------------------------------------------------------------
Control Structures           |
  if                         | (if (condition)    ;; Condition
                             |    (inc a)         ;; True branch
                             |    (inc b))        ;; False branch
                             |
  when (there is no false    | (when (> a 0)
    branch to execute)       |    (println "a > 0")
                             |    (inc a))
                             |
  when-not (there is no true | (when-not (> a 0)
    branch to execute)       |    (println "a <= 0")
                             |    (dec a))
                             |
  Case Expression            | (case x           ;; "x" is the Expression to match
                             |    10 :ten        ;;  case :result
                             |    20 :twenty     ;;  case :result
                             |    50 :fifty      ;;  case :result
                             |    :other)        ;; Default result expression
                             |
  Cond expression            | (cond
                             |    (> x 10) :big_x
                             |    (< a 1)  :small_a
                             |    (= 0 c)  :zero_c)
                             |
--------------------------------------------------------------------------------
Loops                        | (for [i [1 2 3]]
                             |    (inc 1))        ;; Output: (2 3 4)
                             |
--------------------------------------------------------------------------------
The Dot and new operators    | The dot operator, written as a literal ".", forms
                             | the basis for Java interop. When seen by itself
                             | after an opening parenthesis, it should be read a
                             | "in the scope of A do B with arguments..." for example
                             |
                             |   (. Math PI)
                             |   ;; Result: 3.141592653589793
                             |   (. Math abs -3)
                             |   ;; Result: 3
                             |   (. "foo" toUpperCase)
                             |   ;; Result: "FOO"
                             |
                             | To create instance of classes, you can use the
                             | the new operator or a trailing dot to indicate
                             | that the class's constructor should be called
                             |
                             | (new Integer "42")
                             | ;; Result: 42
                             | (Integer. "42")
                             | ;; Result: 42
                             |
